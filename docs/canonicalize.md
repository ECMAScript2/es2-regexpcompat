# Canonicalize

This document describes `src/canonicalize.ts` contents.
`canonicalize.ts` contains two functions:

  - `canonicalize(c: number, unicode: boolean): number` and
  - `uncanonicalize(c: number, unicode: boolean): number[]`

These functions are related to ignore-case matching.

## `canonicalize(c: number, unicode: boolean): number`

It returns the case-folded code point of the given code point `c`.

This function is implementation of `Canonicalize` runtime semantics in ECMA-262 specification:

<https://www.ecma-international.org/ecma-262/10.0/index.html#sec-runtime-semantics-canonicalize-ch>

When `unicode` flag is `true`, case-folding mapping is needed. This mapping is calculated and saved by `tools/make-unicode.ts`.

Otherwise, it implements the algorithm simply.

## `uncanonicalize(c: number, unicode: boolean): number[]`

It is inverse function of `canonicalize`.
It means, it expects `c` is the result of `canonicalize` function, and returns code-points which is canonicalized to `c`.

This function is used for matching character class on ignore-case.
For example, "KELVIN SIGN" character (U+212A, `'â„ª'`) is canonicalized to "LATIN SMALL LETTER K" character (U+006B, `'k'`) on `unicode`.
So, `/[a-z]/iu` must be matched against `'\u212A'`.

For realizing this behavior, a simple solution is calculating canonicalized version of character set before matching.
However it is costed because it needs try to canonicalize against each characters of the set.
Therefore, this function uses when canonicalized `c` is not included in the set.

On unicode the inverse mapping is calculated by the generated `src/data/unicode.ts`.
On non-unicode, the mapping is generated by `tools/make-legacy.ts`, however this mapping does not include all, only includes not `[c.toLowerCase()]` type mapping.
